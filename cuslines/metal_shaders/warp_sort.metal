/* Metal port of cuslines/cuda_c/cuwsort.cuh — bitonic merge sort within a SIMD group.
 *
 * CUDA __shfl_sync → Metal simd_shuffle.
 * Swap networks are embedded as constant arrays.
 */

#include "globals.h"

// ── sort direction ───────────────────────────────────────────────────
#define WSORT_DIR_DEC 0
#define WSORT_DIR_INC 1

// ── swap networks ────────────────────────────────────────────────────
// Batcher's bitonic merge sort comparator networks.

constant int swap32[15][32] = {
    {16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9,10,11,12,13,14,15},
    { 8, 9,10,11,12,13,14,15, 0, 1, 2, 3, 4, 5, 6, 7,24,25,26,27,28,29,30,31,16,17,18,19,20,21,22,23},
    { 4, 5, 6, 7, 0, 1, 2, 3,16,17,18,19,20,21,22,23, 8, 9,10,11,12,13,14,15,28,29,30,31,24,25,26,27},
    { 2, 3, 0, 1, 4, 5, 6, 7,12,13,14,15, 8, 9,10,11,20,21,22,23,16,17,18,19,24,25,26,27,30,31,28,29},
    { 1, 0, 2, 3,16,17,18,19, 8, 9,10,11,24,25,26,27, 4, 5, 6, 7,20,21,22,23,12,13,14,15,28,29,31,30},
    { 0, 1, 2, 3, 8, 9,10,11, 4, 5, 6, 7,16,17,18,19,12,13,14,15,24,25,26,27,20,21,22,23,28,29,30,31},
    { 0, 1, 2, 3, 6, 7, 4, 5,10,11, 8, 9,14,15,12,13,18,19,16,17,22,23,20,21,26,27,24,25,28,29,30,31},
    { 0, 1,16,17, 4, 5,20,21, 8, 9,24,25,12,13,28,29, 2, 3,18,19, 6, 7,22,23,10,11,26,27,14,15,30,31},
    { 0, 1, 8, 9, 4, 5,12,13, 2, 3,16,17, 6, 7,20,21,10,11,24,25,14,15,28,29,18,19,26,27,22,23,30,31},
    { 0, 1, 4, 5, 2, 3, 8, 9, 6, 7,12,13,10,11,16,17,14,15,20,21,18,19,24,25,22,23,28,29,26,27,30,31},
    { 0, 1, 3, 2, 5, 4, 7, 6, 9, 8,11,10,13,12,15,14,17,16,19,18,21,20,23,22,25,24,27,26,29,28,30,31},
    { 0,16, 2,18, 4,20, 6,22, 8,24,10,26,12,28,14,30, 1,17, 3,19, 5,21, 7,23, 9,25,11,27,13,29,15,31},
    { 0, 8, 2,10, 4,12, 6,14, 1,16, 3,18, 5,20, 7,22, 9,24,11,26,13,28,15,30,17,25,19,27,21,29,23,31},
    { 0, 4, 2, 6, 1, 8, 3,10, 5,12, 7,14, 9,16,11,18,13,20,15,22,17,24,19,26,21,28,23,30,25,29,27,31},
    { 0, 2, 1, 4, 3, 6, 5, 8, 7,10, 9,12,11,14,13,16,15,18,17,20,19,22,21,24,23,26,25,28,27,30,29,31}
};

constant int swap16[10][16] = {
    { 8, 9,10,11,12,13,14,15, 0, 1, 2, 3, 4, 5, 6, 7},
    { 4, 5, 6, 7, 0, 1, 2, 3,12,13,14,15, 8, 9,10,11},
    { 2, 3, 0, 1, 8, 9,10,11, 4, 5, 6, 7,14,15,12,13},
    { 1, 0, 2, 3, 6, 7, 4, 5,10,11, 8, 9,12,13,15,14},
    { 0, 1, 8, 9, 4, 5,12,13, 2, 3,10,11, 6, 7,14,15},
    { 0, 1, 4, 5, 2, 3, 8, 9, 6, 7,12,13,10,11,14,15},
    { 0, 1, 3, 2, 5, 4, 7, 6, 9, 8,11,10,13,12,14,15},
    { 0, 8, 2,10, 4,12, 6,14, 1, 9, 3,11, 5,13, 7,15},
    { 0, 4, 2, 6, 1, 8, 3,10, 5,12, 7,14, 9,13,11,15},
    { 0, 2, 1, 4, 3, 6, 5, 8, 7,10, 9,12,11,14,13,15}
};

constant int swap8[6][8] = {
    { 4, 5, 6, 7, 0, 1, 2, 3},
    { 2, 3, 0, 1, 6, 7, 4, 5},
    { 1, 0, 4, 5, 2, 3, 7, 6},
    { 0, 1, 3, 2, 5, 4, 6, 7},
    { 0, 4, 2, 6, 1, 5, 3, 7},
    { 0, 2, 1, 4, 3, 6, 5, 7}
};

constant int swap4[3][4] = {
    { 2, 3, 0, 1},
    { 1, 0, 3, 2},
    { 0, 2, 1, 3}
};

constant int swap2[1][2] = {
    { 1, 0}
};

// ── key-only sort ────────────────────────────────────────────────────

template<int GSIZE, int DIRECTION>
inline float warp_sort_key(float v, uint gid) {
    const int NSWAP = (GSIZE == 2) ? 1 : (GSIZE == 4) ? 3 : (GSIZE == 8) ? 6 : (GSIZE == 16) ? 10 : 15;

    for (int i = 0; i < NSWAP; i++) {
        int srclane;
        if      (GSIZE == 32) srclane = swap32[i][gid];
        else if (GSIZE == 16) srclane = swap16[i][gid];
        else if (GSIZE ==  8) srclane = swap8[i][gid];
        else if (GSIZE ==  4) srclane = swap4[i][gid];
        else                  srclane = swap2[i][gid];

        float a = simd_shuffle(v, ushort(srclane));
        v = ((int(gid) < srclane) == DIRECTION) ? MIN(a, v) : MAX(a, v);
    }
    return v;
}

// ── key-value sort ───────────────────────────────────────────────────

template<int GSIZE, int DIRECTION>
inline void warp_sort_kv(thread float& k, thread int& val, uint gid) {
    const int NSWAP = (GSIZE == 2) ? 1 : (GSIZE == 4) ? 3 : (GSIZE == 8) ? 6 : (GSIZE == 16) ? 10 : 15;

    for (int i = 0; i < NSWAP; i++) {
        int srclane;
        if      (GSIZE == 32) srclane = swap32[i][gid];
        else if (GSIZE == 16) srclane = swap16[i][gid];
        else if (GSIZE ==  8) srclane = swap8[i][gid];
        else if (GSIZE ==  4) srclane = swap4[i][gid];
        else                  srclane = swap2[i][gid];

        float a = simd_shuffle(k, ushort(srclane));
        int   b = simd_shuffle(val, ushort(srclane));

        if ((int(gid) < srclane) == DIRECTION) {
            if (a < k) { k = a; val = b; }
        } else {
            if (a > k) { k = a; val = b; }
        }
    }
}
